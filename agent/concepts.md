# Architecture Reference: Embedded Firmware Analyst Agent

**Objective:** Create a local, interactive AI agent capable of reasoning across three domains: C Source Code (Patch), Compiled Artifacts (Object Files), and Legacy Firmware Binaries.
**Constraints:** Offline/Air-gapped operation, Python-based, Textual UI.

-----

## 1\. High-Level Concept: "The Triangulation Engine"

The core architectural principle is that the AI does not "know" the code. Instead, it acts as a central operator that "triangulates" truth by querying three distinct data domains.

### The Three Domains

1.  **The Intent (Source Code):** The C files you are writing.
      * *Tool:* `libclang` (Python bindings).
      * *Role:* Provides semantic understanding (AST) of the patch logic.
2.  **The Reality (Firmware Binary):** The legacy binary on the device.
      * *Tool:* SQLite (Metadata) + Capstone (Raw Bytes).
      * *Role:* Provides ground truth about addresses, existing symbols, and instruction sets (PPC/ARM).
3.  **The Artifact (Compiled Patch):** The object file generated by the compiler.
      * *Tool:* `pyelftools` / `readelf`.
      * *Role:* Verifies relocation logic, section sizes, and reachability (branch distances).

-----

## 2\. Data Layer Strategy (The Offline ETL)

Since you cannot access the Ghidra server dynamically, you must rely on a **Nightly ETL (Extract, Transform, Load)** process.

### 2.1 The SQLite Schema (`firmware_analysis.db`)

This database acts as the "Index" for the agent.

```sql
-- The Nouns: Functions and Globals
CREATE TABLE symbols (
    address INTEGER PRIMARY KEY,
    name TEXT,
    size INTEGER,
    segment TEXT, -- 'text', 'data', 'bss'
    is_function BOOLEAN
);

-- The Verbs: The Call Graph and Data References
CREATE TABLE xrefs (
    source_addr INTEGER,
    target_addr INTEGER,
    ref_type TEXT, -- 'CALL', 'READ', 'WRITE', 'POINTER'
    instruction_mnemonic TEXT, -- e.g., 'BL', 'LDR'
    FOREIGN KEY(source_addr) REFERENCES symbols(address),
    FOREIGN KEY(target_addr) REFERENCES symbols(address)
);

-- The Context: Cached Decompilation (Optional but recommended)
CREATE TABLE decompilation (
    address INTEGER PRIMARY KEY,
    c_source TEXT
);
```

### 2.2 The Raw Artifacts

Files you must synchronize to the local agent environment:

1.  `firmware_analysis.db` (The SQLite DB generated above).
2.  `firmware.bin` (The raw binary dump, for byte-level inspection).
3.  `repo/` (The git-svn clone of your source code).

-----

## 3\. Application Architecture (Python)

The application is built on the **Notebook/REPL Pattern**. The Agent generates Python code, executes it, and analyzes the result.

### 3.1 The "Context" Classes (The API)

These classes form the namespace available to the Agent.

#### `FirmwareContext` (Read-Only)

Handles the "Reality" domain.

  * **Input:** Path to `firmware_analysis.db`, Path to `firmware.bin`.
  * **Key Libraries:** `sqlite3`, `capstone`.
  * **Key Methods:**
      * `get_symbol(name) -> SymbolObj`: Returns address/size.
      * `get_xrefs_to(address)`: Who calls this?
      * `read_bytes(address, length)`: Reads from the raw `.bin`.
      * `disassemble(address, count)`: Uses **Capstone** to return assembly text. *Crucial for handling PPC vs ARM differences.*

#### `SourceContext` (Read-Write)

Handles the "Intent" domain.

  * **Input:** Path to `repo/`.
  * **Key Libraries:** `clang.cindex`.
  * **Key Methods:**
      * `reload()`: Re-parses the C files (call this after you edit code).
      * `get_macro_value(name)`: (See Section 4.2 below).
      * `find_function_def(name)`: Returns the file and line number.

#### `ArtifactContext` (Validation)

Handles the "Artifact" domain.

  * **Input:** Path to compiled `.o` files.
  * **Key Libraries:** `pyelftools`.
  * **Key Methods:**
      * `get_section_size(section_name)`: Checks if your patch fits in the hole.
      * `get_relocations()`: Checks what external symbols the patch needs.

### 3.2 The Master Controller

This is the object the agent actually interacts with.

```python
class AnalysisContext:
    def __init__(self):
        self.fw = FirmwareContext(...)
        self.src = SourceContext(...)
        self.art = ArtifactContext(...)

    def verify_patch_linkage(self, patch_func, target_addr_macro):
        """
        High-level tool: Verifies that the C macro matches the
        Ghidra address for a specific function.
        """
        # Logic to cross-reference self.src and self.fw
        pass
```

-----

## 4\. Implementation Details (The "How-To")

### 4.1 The Textual Execution Engine (Worker API)

**Problem:** Running `libclang` or huge SQL queries freezes the UI.
**Solution:** Use Textual's `@work` decorator. **Do not use Subprocesses/IPC.** Subprocesses cannot share the complex `clang` objects in memory.

**File:** `agent_runner.py`

```python
import io
import contextlib
from textual import work
from textual.app import App
from textual.widgets import Log

class AgentApp(App):
    # ... UI setup ...

    def on_mount(self):
        # Initialize the heavy Contexts once
        self.ctx = AnalysisContext()

    async def on_user_input(self, code_str):
        # Trigger the worker
        self.run_agent_code(code_str)

    @work(exclusive=True, thread=True)
    def run_agent_code(self, code: str):
        """
        Executes agent code in a thread, sharing memory with the main app.
        """
        # 1. Capture Stdout (so the agent can 'print')
        str_io = io.StringIO()

        # 2. Define the Namespace
        # This gives the code access to your AnalysisContext
        env = {
            "ctx": self.ctx,
            "print": lambda *args: print(*args, file=str_io)
        }

        # 3. Execute
        try:
            exec(code, env)
            result = str_io.getvalue()
        except Exception as e:
            result = f"Error: {e}"

        # 4. Thread-Safe UI Update
        # CRITICAL: You must use call_from_thread to touch widgets
        self.app.call_from_thread(self.write_to_log, result)

    def write_to_log(self, text):
        self.query_one(Log).write(text)
```

### 4.2 Handling C Macros (The LibClang Trick)

Since you are patching, you likely use `#define` to set target addresses. Standard `libclang` traversals often miss these. Use this pattern in your `SourceContext`:

```python
import clang.cindex

def get_macro_values(tu):
    """
    Extracts #defines.
    Requires parsing with:
    options=clang.cindex.TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD
    """
    macros = {}
    for cursor in tu.cursor.get_children():
        if cursor.kind == clang.cindex.CursorKind.MACRO_DEFINITION:
            # Tokenize to get the value
            tokens = list(cursor.get_tokens())
            if len(tokens) > 1:
                # tokens[0] is the name, tokens[1:] is the value
                val = "".join([t.spelling for t in tokens[1:]])
                macros[cursor.spelling] = val
    return macros
```

-----

## 5\. Deployment Checklist (The "Shopping List")

Before you enter the air-gapped environment, ensure you have mirrored/downloaded these PyPI packages:

1.  **`textual`**: The UI framework.
2.  **`libclang`**: The Python bindings for Clang.
      * *Note:* You also need the `libclang.so` or `libclang.dll` binary installed on the system.
3.  **`capstone`**: The disassembly framework.
      * *Note:* Essential for switching between PowerPC, ARM, and M68k decoding dynamically.
4.  **`pyelftools`**: Pure Python library for parsing ELF/.o files.
5.  **`llm` / `llama-cpp-python`**: Whatever local inference engine you are using.

-----

## 6\. The "Golden Loop" (Workflow)

Once implemented, your workflow inside the secure environment looks like this:

1.  **Sync:** Pull `firmware.bin` and `firmware_analysis.db` (Nightly).
2.  **Code:** You write C code in your IDE.
3.  **Consult:** You Alt-Tab to the Agent App.
      * *You:* "Check if `HW_REG_ADDR` in my code matches the `hardware_init` register usage in the firmware."
4.  **Agent:**
      * Reads your C file macro (SourceContext).
      * Disassembles `hardware_init` in the binary (FirmwareContext/Capstone).
      * Compares the immediate values.
      * *Output:* "Mismatch. You defined `0x4000`, but firmware uses `0x4010`."
5.  **Fix:** You update your C code.
6.  **Compile:** You run Make.
7.  **Verify:** Agent checks the generated `.o` file for relocation safety.

This architecture avoids the complexity of IPC, solves the "read-only binary" problem via SQLite/Capstone, and keeps the heavy lifting (Ghidra) in the nightly ETL.
